#region File Description
//-----------------------------------------------------------------------------
// BloomComponent.cs
//
// Microsoft XNA Community Game Platform
// Copyright (C) Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#endregion

#region Using Statements
using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Content;
using Microsoft.Xna.Framework.Graphics;
using XNABuilder;
using System.IO;
using System.Collections.Generic;
using System.Collections;
using XNASysLib.XNAKernel;
#endregion

namespace XNASysLib.Primitives3D
{

    public class ScenePrimitive : GeometricPrimitive, ISelectable//, IEnumerator<IDrawableComponent>, IEnumerable<IDrawableComponent>
    {

        float _modelRadius;
        protected string _ID;
        protected GraphicsDevice _device;
   
        protected SelectableCompData _data;


        protected GraphicsDevice GraphicsDevice;
        protected Matrix[] _boneTransforms;
        protected Vector3 _modelCenter;
        protected ContentBuilder _contentBuilder;
        protected string _AssetNm;
        

        protected Vector3 _scale;
        protected Quaternion _rotQuaternion;
        protected Vector3 _rotation; 
        protected Vector3 _translation;
        protected RasterizerState _rasterizerState;

       
        public SelectableCompData Data
        {
            get
            {
                return this._data;
            }
        }

        #region showProperties



        public override Matrix World
        {
            get { return _world; }
            set 
            {
                _world = value;
                this._data.dataModifitionHandler.Invoke();
            }
        }

        [MyShowProperty]
        public float TranslateX
        {
            get { return _translation.X; }
            set
            {

                _translation.X = value;
                _world = Matrix.CreateFromQuaternion(_rotQuaternion) *
               Matrix.CreateTranslation(_translation) *
               Matrix.CreateScale(_scale);
                this._data.dataModifitionHandler.Invoke();
            }
        }
        [MyShowProperty]
        public float TranslateY
        {
            get { return _translation.Y; }
            set
            {
                _translation.Y = value;
                _world = Matrix.CreateFromQuaternion(_rotQuaternion) *
               Matrix.CreateTranslation(_translation) *
               Matrix.CreateScale(_scale);
                this._data.dataModifitionHandler.Invoke();
            }
        }
        [MyShowProperty]
        public float TranslateZ
        {
            get
            {

                return _translation.Z;
            }
            set
            {
                _translation.Z = value;
                _world = Matrix.CreateFromQuaternion(_rotQuaternion) *
               Matrix.CreateTranslation(_translation) *
               Matrix.CreateScale(_scale);
                this._data.dataModifitionHandler.Invoke();
            }
        }
        [MyShowProperty]
        public float RotationX
        {
            get
            {
                return _rotation.X;
            }
            set
            {
                _rotation.X = (value);
                AbsoluteRotation();

                this._data.dataModifitionHandler.Invoke();
            }
        }
        [MyShowProperty]
        public float RotationY
        {
            get
            {
                return _rotation.Y;
            }
            set
            {
                _rotation.Y = (value);
                AbsoluteRotation();

                this._data.dataModifitionHandler.Invoke();
            }
        }
        [MyShowProperty]
        public float RotationZ
        {
            get
            {
                return _rotation.Z;
            }
            set
            {
                _rotation.Z = (value);
                AbsoluteRotation();

                this._data.dataModifitionHandler.Invoke();
            }
        }

        #endregion

        

        public ScenePrimitive(IGame game):base(game)
           
        {
            _world = Matrix.Identity;
            _translation = Vector3.Zero;
            _rotQuaternion = Quaternion.Identity;
            _scale = Vector3.One;

            this._data.IsVisible = true;
            //TempCode
            this._data.IsInCam = true;

            this._data.dataModifitionHandler += OnModify;
            this._data.SelectionHandler += OnSeletion;
            _rasterizerState = RasterizerState.CullNone;
        }
       
        void OnSeletion(bool isSelected)
        {
            if (isSelected)
            {
                _rasterizerState = new RasterizerState()
                {
                    FillMode = FillMode.WireFrame,
                    CullMode = CullMode.None,
                };
                //((Scene)_game).SelectorHandler.Invoke(this);
            }
            else
            {
                _rasterizerState = RasterizerState.CullNone;
               // ((Scene)_game).SelectorHandler.Invoke(null);
            } 
        }
        void OnModify()
        {

            this._data.BoundingSpheres =
                new BoundingSphere[1];
            
            this._data.BoundingSpheres[0].Center
                = Vector3.Transform( this._modelCenter,this._world);
            this._data.BoundingSpheres[0].Radius
                = this._modelRadius+0.1f;

        }
        public override void Initialize()
        {
           
            GraphicsDevice = ((IGraphicsDeviceService )_game.Services.
                GetService(typeof(IGraphicsDeviceService))).GraphicsDevice;
            base.Initialize();
        }
        protected override void LoadContent()
        {
           _modelCenter = Vector3.Zero;

           foreach (VertexPositionNormal vecs in this._vertices)
            {

                _modelCenter += vecs.Position;
            }
           _modelCenter /= this._vertices.Count;


            // Now we know the center point, we can compute the model radius
            // by examining the radius of each mesh bounding sphere.
            _modelRadius = 0;

            foreach (VertexPositionNormal vecs in this._vertices)
            {

                float radius = (_modelCenter - vecs.Position).Length();

                _modelRadius = Math.Max(_modelRadius, radius);
            }

            this._data.dataModifitionHandler.Invoke();
        }
        public override void Update(GameTime gameTime)
        {
            //TempCode 1012
            if (!_isInitialized)
                this.Initialize();


           

            if (!SelectFunction.Selection.Contains(this))
                this.OnSeletion(false);
            base.Update(gameTime);
        }
        public override void Draw(GameTime gameTime)
        {
            _game.GraphicsDevice.RasterizerState =
                RasterizerState.CullNone;
            if (_rasterizerState.FillMode == FillMode.WireFrame)
            {
                _color = Color.Yellow;
            }
            else
                _color = Color.Red;
            base.Draw(gameTime);

                

       }



        protected void AbsoluteRotation()
        {

            Vector3 radianAngle = (_rotation / 360) * 2 * MathHelper.Pi;
            _rotQuaternion = Quaternion.Identity;
            _rotQuaternion = Quaternion.Normalize(
                    Quaternion.CreateFromYawPitchRoll
                    (radianAngle.Y, radianAngle.X, radianAngle.Z)
                );
            _world = Matrix.CreateFromQuaternion(_rotQuaternion) *
               Matrix.CreateTranslation(_translation) *
               Matrix.CreateScale(_scale);

        }
        protected void RelativeRotation(Vector3 axis, float angle)
        {
            angle = (angle / 360) * 2 * MathHelper.Pi;
            axis = Vector3.Transform(axis, Matrix.CreateFromQuaternion(_rotQuaternion));
            _rotQuaternion = Quaternion.Normalize(
                                                Quaternion.CreateFromAxisAngle(axis, angle)
                                                *
                                                _rotQuaternion
                                                );
        }

        }
    }

