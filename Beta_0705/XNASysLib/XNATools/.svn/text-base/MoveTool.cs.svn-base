using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Graphics;
using System;
using XNASysLib.XNAKernel;
using System.Collections.Generic;
using XNASysLib.Primitives3D;
using XNAPhysicsLib;

namespace XNASysLib.XNATools
{
    public class MoveTool : aCTool
    {

        IHotSpot _hotSpot;
        Point? _start;
        List<ISelectable> _HotReg = new List<ISelectable>();
        DataReactor _dataR;
        DebugDraw _debugDraw;

        ToolPart _xaxis;
        ToolPart _yaxis;
        ToolPart _zaxis;
        ISelectable _curAxis;
        Vector3 _translate;
       
        public MoveTool(IGame game, IDrawableComponent target)
            : base(game)
        {
          
            this._game.Components.Add(this);
            _translate = target.World.Translation;
            this._toolTarget = target;
        }
        public override void Initialize()
        {
            _dataR = DataReactor.GetDataReactor();
            _world = Matrix.Identity;

            _xaxis = new ToolPart(_game, Vector3.Right);
            _yaxis = new ToolPart(_game, Vector3.Up);
            _zaxis = new ToolPart(_game, Vector3.Backward);

            _xaxis.DragHandler += this.OnDragX;
            _yaxis.DragHandler += this.OnDragY;
            _zaxis.DragHandler += this.OnDragZ;

            this._hotSpots.Add(_xaxis);
            this._hotSpots.Add(_yaxis);
            this._hotSpots.Add(_zaxis);

            foreach (IHotSpot spot in this._hotSpots)
                if (spot is IDrawableComponent)
                    ((IDrawableComponent)spot).Initialize();

            this._debugDraw = new
                DebugDraw(_game.GraphicsDevice);

            if (this._cam == null)
                _cam = (ICamera)_game.Services.GetService(typeof(ICamera));

            base.Initialize();
        }
        public override void Update(GameTime gameTime)
        {

            if (!_isInitialized)
                this.Initialize();

            if (DataReactor.GetDataReactor()
                .MouseData.IsLeftBtnDown && _start == null
                && _HotReg.Count!=0)
                _start = DataReactor.GetDataReactor().MousePos.Value;
            
            if (!DataReactor.GetDataReactor()
                .MouseData.IsClicking)
                _start = null;

            if (!_dataR.MousePos.HasValue)
                return;
            bool test = false;
            foreach (IHotSpot spot in this._hotSpots)
            {
                ISelectable scomp = ((ISelectable)spot);

                if (spot is IDrawableComponent)
                    ((IDrawableComponent)spot).Update(gameTime);



                Vector2 mousePos = new Vector2(
                    _dataR.MousePos.Value.X,
                    _dataR.MousePos.Value.Y);

                Ray r = _dataR.CalculateCursorRay(mousePos);

                if (_dataR.CalculateIntersection
                    (r, ((ISelectable)spot).Data))
                {

                    test |= true;

                    if (!_HotReg.Contains(scomp))
                        _HotReg.Add(scomp);

                    /* if (_dataR.MouseSelection.HasValue &&
                            _dataR.MouseSelection.Value.Width == 1 &&
                            _dataR.MouseSelection.Value.Height == 1)*/
                    if(!_dataR.MouseData.IsMoving&&_dataR.MouseData.IsLeftBtnDown)
                    {
                        _curAxis = scomp;
                       ((ISelectable)_curAxis).Data.SelectionHandler.Invoke(true);
                        
                    }


                    if (scomp is IDraggable)
                    {
                        if (_dataR.MouseData.IsDragging && 
                            Keyboard.GetState().IsKeyUp(Keys.LeftAlt))
                        {
                            IDraggable drcomp = (IDraggable)scomp;
                            if (_HotReg.Contains(scomp)&&_curAxis==scomp)
                            {
                                if (!_start.HasValue)
                                    _start = _dataR.MousePos.Value;
                                try
                                {
                                    drcomp.DragHandler.Invoke(_start.Value,
                                        _dataR.MousePos.Value);
                                }
                                catch (Exception e)
                                {
                                    throw new ArgumentNullException();
                                }
                            }
                        }
                    }
                }


                else//else not onrollover
                {
                    if (_HotReg.Contains(scomp))
                        _HotReg.Remove(scomp);
              
                    if (!_dataR.MouseData.IsMoving&&_dataR.MouseData.IsLeftBtnDown&&_curAxis==scomp
                        &&Keyboard.GetState().IsKeyUp(Keys.LeftAlt))
                    {

                        /*
                            ((ISelectable)_curAxis).Data.SelectionHandler.Invoke(false);
                            _curAxis = null;
                            SelectFunction.Selection.Clear();
                        */
                    }

                
                }
            }

            if (!test && _dataR.MouseData.IsClicking && Keyboard.GetState().IsKeyUp(Keys.LeftAlt))
            {

                SelectFunction.Selection.Clear();
            }
            this._world = Matrix.CreateTranslation(_translate);
            _xaxis.World = Matrix.CreateTranslation(_translate.X + 1, _translate.Y, _translate.Z);
            _yaxis.World = Matrix.CreateTranslation(_translate.X , _translate.Y+1, _translate.Z);
            _zaxis.World = Matrix.CreateTranslation(_translate.X, _translate.Y, _translate.Z+1);

            this._toolTarget.World = _world;

            base.Update(gameTime);
        }
        public override void Draw(GameTime gameTime)
        {

            _debugDraw.Begin(Matrix.Multiply(Matrix.Identity, _cam.ViewMatrix),
            _cam.ProjectionMatrix);

            DepthStencilState _curState = _game.GraphicsDevice.DepthStencilState;
           
            _game.GraphicsDevice.DepthStencilState = DepthStencilState.None;

            

            foreach (IHotSpot spot in this._hotSpots)
                if (spot is IDrawableComponent)
                    ((IDrawableComponent)spot).Draw(gameTime);

            
            _game.GraphicsDevice.DepthStencilState = _curState;
           

            foreach (ISelectable scomp in _HotReg)
            {
                BoundingSphere sphere=scomp.Data.BoundingSpheres[0];
                sphere.Radius=1.03f;
                _debugDraw.DrawWireSphere(sphere,
                    Color.Red);
            }


            _debugDraw.DrawLine(_translate,new Vector3(_translate.X+1,_translate.Y,_translate.Z),Color.Red);

            _debugDraw.DrawLine(_translate, new Vector3(_translate.X , _translate.Y+1, _translate.Z), Color.Green);

            _debugDraw.DrawLine(_translate, new Vector3(_translate.X, _translate.Y, _translate.Z+1), Color.Blue);
            _debugDraw.End();
            base.Draw(gameTime);
        }
        void OnDragY(Point scrPStart, Point scrPEnd)
        {
            float disY;
            Ray start = CalculateCursorRay
                (new Vector2(scrPStart.X, scrPStart.Y));
            Ray end = CalculateCursorRay
                (new Vector2(scrPEnd.X, scrPEnd.Y));

            float? startDis = start.Intersects(new Plane(Vector3.UnitZ,0f));
            float? endDis = end.Intersects(new Plane(Vector3.UnitZ, 0f));

            Vector3 startVec = start.Position + start.Direction * startDis.Value;
            Vector3 endVec = end.Position + end.Direction * endDis.Value;

            disY = endVec.Y - startVec.Y;
            this._translate.Y = disY;
            MyConsole.WriteLine("asdf" + disY.ToString());
        }
        void OnDragX(Point scrPStart, Point scrPEnd)
        {
            float disX;
            Ray start = CalculateCursorRay
                (new Vector2(scrPStart.X, scrPStart.Y));
            Ray end = CalculateCursorRay
                (new Vector2(scrPEnd.X, scrPEnd.Y));

            float? startDis = start.Intersects(new Plane(Vector3.UnitZ, 0f));
            float? endDis = end.Intersects(new Plane(Vector3.UnitZ, 0f));

            Vector3 startVec = start.Position + start.Direction * startDis.Value;
            Vector3 endVec = end.Position + end.Direction * endDis.Value;
            
            disX = endVec.X - startVec.X;
            this._translate.X = disX;
            MyConsole.WriteLine("asdf" + disX.ToString());
        }
        void OnDragZ(Point scrPStart, Point scrPEnd)
        {
            float disZ;
            Ray start = CalculateCursorRay
                (new Vector2(scrPStart.X, scrPStart.Y));
            Ray end = CalculateCursorRay
                (new Vector2(scrPEnd.X, scrPEnd.Y));

            float? startDis = start.Intersects(new Plane(Vector3.UnitX, 0f));
            float? endDis = end.Intersects(new Plane(Vector3.UnitX, 0f));

            Vector3 startVec = start.Position + start.Direction * startDis.Value;
            Vector3 endVec = end.Position + end.Direction * endDis.Value;

            disZ = endVec.Z - startVec.Z;
            this._translate.Z = disZ;
            MyConsole.WriteLine("asdf" + disZ.ToString());
        }
        Ray CalculateCursorRay(Vector2 position)
        {

            Matrix projectionMatrix = _cam.ProjectionMatrix;
            Matrix viewMatrix = _cam.ViewMatrix;

            // create 2 positions in screenspace using the cursor position. 0 is as
            // close as possible to the camera, 1 is as far away as possible.
            Vector3 nearSource = new Vector3(position, 0f);
            Vector3 farSource = new Vector3(position, 1f);

            // use Viewport.Unproject to tell what those two screen space positions
            // would be in world space. we'll need the projection matrix and view
            // matrix, which we have saved as member variables. We also need a world
            // matrix, which can just be identity.
            Vector3 nearPoint = _game.GraphicsDevice.Viewport.Unproject(nearSource,
                projectionMatrix, viewMatrix, Matrix.Identity);

            Vector3 farPoint = _game.GraphicsDevice.Viewport.Unproject(farSource,
                projectionMatrix, viewMatrix, Matrix.Identity);

            // find the direction vector that goes from the nearPoint to the farPoint
            // and normalize it....
            Vector3 direction = farPoint - nearPoint;
            direction.Normalize();

            // and then create a new ray using nearPoint as the source.
            return new Ray(nearPoint, direction);
        }

    }
    public class ToolPart : SpherePrimitive, IHotSpot,IDraggable
    {
        public GeometricPrimitive model
        { get { return this; } }

        BoundingSphere _boundingSphere;
        OnSelected _selectionHandler;
        Vector3 _axis;
        protected OnDrag _dragHandler;

        public OnDrag DragHandler
        { get { return _dragHandler; }
            set { _dragHandler = value; }
        }


        public OnSelected SelectionHandler
        { get { return _selectionHandler; } }
        public BoundingSphere BoundingSphere
        { get { return _boundingSphere; } }

        public ToolPart(IGame game, Vector3 axis)
            : base(game, 0.2f,16)
        { 
            //this._dragHandler+=OnDrag;
            _axis = axis;
            
            this.TranslateX = axis.X;
            this.TranslateY = axis.Y;
            this.TranslateZ = axis.Z;
        }
      
    }

}